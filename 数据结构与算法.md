## 数据结构与算法

### 一、数组

1. 双指针
2. 二分查找

### 二、链表

##### 1.链表遍历

- 一般遍历基本框架

```python
prev=None
curr=head
while curr:
    if not pre:
        #处于头部
    else:
        #非头部操作
    prev=curr
    curr=cuu.next
```

- 带哑节点的遍历

```python
dummy=ListNode(-1)
prev=dummy #能够统一处理
curr=head
while curr:
    #xxx
    prev=curr
    curr=curr.next
```

##### 2.链表反转

- 递归

  ```python
  #思考递归时，不要模拟过程，关注定义本身，处理好边界
  #定义：输入一个节点 head，将「以 head 为起点」的链表反转，并返回反转之后的头结点。
  ListNode reverse(head：ListNode)--> ListNode {
      if not head:
      	return head
      #反转下一个节点后续的链表，得到的是链表最后的节点 新的头节点
      last=reverse(head.next)
      # 接上链表 断掉的位置
      head.next.next=head
      #反转后的最后一个节点 指向空
      head.next=None
      return last
  }
  ```

  进一步 ：反转前N个节点

  ```python
  #记录第N个节点，下一个节点，反转后的链表最后要指向它。不再是指向空。
  ListNode p=None
  # 反转以 head 为起点的 n 个节点，返回新的头结点
  def reverseN(head:ListNode, n：int) --> ListNode {
      #处理边界当n=1时
      if n==1:
      	p=head.next
      	return head
     	#反转下一个节点后续的链表，得到的是链表最后的节点 新的头节点
      last=reverseN(head.next,n-1)
      # 接上链表 断掉的位置
      head=head.next.next
      # 最后需要指向那个p节点
      head.next=p
      #返回前面反转后的头节点即last
     	return last
  }
  ```

  进一步 ：反转链表的一部分 反转区间 [m,n]的节点

  ```python
  def reverseBetween(head：ListNode, m :int, n :int) --> ListNode {
      #处理边界
      if m==1:
      	return reverseN(head,n)
      #当前继续往下走，直到反转起点
      head.next=reverseBetween(head.next,m-1,n-1)
      # 返回头节点，前M个未反转与后面全部反转的表头
      return head    
  }
  ```

- 迭代

  ```python
  #使用遍历模板
  def reverseList(self, head: ListNode) --> ListNode:
      prev=None
      curr=head
      while curr:
          #保存下个节点
          cnext=curr.next
          if not prev:
              curr.next=None
          else:
              curr.next=prev
          prev=curr
          curr=cnext
      #返回时curr为空，pre为最后一个节点，即反转后的头节点
      return pre
  ```

  简化为：

  ```python
  #使用遍历模板
  def reverseList(self, head: ListNode) --> ListNode:
      prev=None
      curr=head
      while curr:
          #保存下个节点
          cnext=curr.next
          #反转
      	curr.next=prev
          #继续迭代下去
          prev=curr
          curr=cnext
      #返回时curr为空，pre为最后一个节点，即反转后的头节点
      return head
  ```

  
  
  链表遍历与反转参考题：
  
  [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
  
  [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
  
  [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)
  
  [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

##### 3.链表中的双指针

- 链表中点

  ```python
  def middleNode(head:ListNode) --> ListNode :{
      slow=head
      fast=head.next
      while fast:
      	slow=slow.next
      	fast=fast.next.next
      return slow
  }
  ```

- 倒数第K个元素

  ```python
  def KthFromEndNode(head:ListNode,k) --> ListNode:{
      slow=head
      fast=head
      for i in range(k):
      	fast=fast.next
     	while fast:
      	slow=slow.next
      	fast=fast.next
     	return slow
  }
  ```

- 链表是否存在回环

  ```python
  def hasCycle(head:ListNode):->bollean {
      slow = head
      fast = head    
      while fast and fast.next
          fast = fast.next.next
          slow = slow.next
          #fast 和 slow 指向同一个结点，说明存在环
          if fast == slow:
              return True
      #fast 到达链表尾部，则不存在环
      return False
  }
  ```



参考题：

[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

[19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)



##### 4.链表排序





参考题：

[147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

[148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)	

[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)	



### 三、二叉树

1. 前序遍历
   - 递归
   - 迭代
2. 中序遍历
   - 递归
   - 迭代
3. 后序遍历
   - 递归
   - 迭代
4. 层次遍历
   - 递归
   - 迭代
5. DFS与BFS框架



### 四、字符串

### 五、算法

- ##### 贪心

- ##### 回溯

- ##### 分治

- ##### 动态规划

- ##### 排序

  - 快速排序

  ```
  
  ```

  